## 数组详解

`[...]int{1,2,3}`为语法糖 

数组长度小于 4 时候 直接将元素放置栈上 

元素数量大于四的时候 将数组中的元素放到静态区 2 并在运行时候去取出







## 哈希表



```go
type hmap struct {
// 当前哈希表中的元素数量
    count     int

	flags     uint8
    // 桶的数量  buckets  均为 2 的倍数 len(buckets)==2^B
	B         uint8
	noverflow uint16
    // 哈希的种子 为哈希函数的结果引入随机性
	hash0     uint32
	
	buckets    unsafe.Pointer
    // 哈希扩容时用与保存之前的 buckets 大小是当前的buckets 的一半
	oldbuckets unsafe.Pointer
	nevacuate  uintptr

	extra *mapextra
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```



![5zbMf4](https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/5zbMf4.png)

- #### 链地址法

  - 所有碰撞元素用单链表串起来

  - ``` java
    Hash(Key) = Key % N;
    ```

#### 开放地址法

- 线性探测 哈希函数输出的散列表位置存在元素 则

  - `(Hash(x)+1)%N` 重取下标

- 平方探测

  - 向下探测宽度变为 i^2

- 双重/再哈希

  - 对结果再次哈希 考虑装填负载因子

    




### map 实现

- 初始化：
  - 哈希表中的数量少于等于 25 时候 将所有的键值对一次性加入到哈希表中  初始化类似数组和切片 
  - 超过的时候风别创建两个数组存储键值  for 循环加入到哈希中
- 小容量的哈希优化 分配到栈上 并且容量小于 buckets<8   





- make 创建时 `runtime.makemap`
  - 计算哈希占用的内存是否溢出或者超出最大值
  - 获得哈希种子随机数 `runtime.fastrand`
  - hit 计算最小需要的桶的数量
  - `runtime.makeBucketArray`创建保存桶的数组



### Tips

Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 `tophash` 就成为可以帮助哈希快速遍历桶中元素的缓存。

哈希表的每个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。

 







































































